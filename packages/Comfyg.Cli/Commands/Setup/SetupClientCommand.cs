using System.CommandLine;
using System.CommandLine.Invocation;
using System.Security.Cryptography.X509Certificates;
using Comfyg.Cli.Extensions;
using Spectre.Console;

namespace Comfyg.Cli.Commands.Setup;

internal class SetupClientCommand : Command
{
    private readonly Argument<string> _clientIdArgument;
    private readonly Argument<string> _friendlyNameArgument;
    private readonly Option<FileInfo> _publicKeyOption;

    public SetupClientCommand() : base("client", "Registers a new client on the connected Comfyg store.")
    {
        _clientIdArgument = new Argument<string>("CLIENT_ID",
            "The ID of the client to create. This must be unique for the connected Comfyg store.");
        AddArgument(_clientIdArgument);

        _friendlyNameArgument = new Argument<string>("FRIENDLY_NAME",
            "The user friendly display name which is used for the created client.");
        AddArgument(_friendlyNameArgument);

        _publicKeyOption = new Option<FileInfo>(new[] { "-pk", "--public-key" },
            "Path to a X.509 certificate which contains the public key portion of the client secret. If not provided a symmetric client secret will be generated by the Comfyg store instead.");
        AddOption(_publicKeyOption);

        this.SetHandler(HandleCommandAsync);
    }

    private async Task HandleCommandAsync(InvocationContext context)
    {
        var clientIdArgument = context.ParseResult.GetValueForArgument(_clientIdArgument);
        var friendlyNameArgument = context.ParseResult.GetValueForArgument(_friendlyNameArgument);
        var publicKeyOption = context.ParseResult.GetValueForOption(_publicKeyOption);

        Stream? publicKey = null;
        if (publicKeyOption != null)
        {
            if (!publicKeyOption.Exists)
                throw new FileNotFoundException("Could not find provided public key file.", publicKeyOption.FullName);

            var certificate = new X509Certificate2(publicKeyOption.FullName);
            if (certificate.HasPrivateKey)
                throw new InvalidOperationException("The provided public key file also contains the private key.");

            publicKey = new MemoryStream(certificate.Export(X509ContentType.Cert));
        }

        var cancellationToken = context.GetCancellationToken();

        using var client = await State.User.RequireClientAsync(cancellationToken);

        var result = await client.SetupClientAsync(
            new Client.Client(clientIdArgument, friendlyNameArgument, publicKey != null), publicKey, cancellationToken);

        if (publicKey != null) await publicKey.DisposeAsync();

        AnsiConsole.MarkupLine($"[bold green]Successfully created a client for {client.EndpointUrl}[/]");

        AnsiConsole.Write(result.Client.ToTable(result.ClientSecret));

        AnsiConsole.MarkupLine("[bold yellow]Make sure to copy the client secret before closing the terminal![/]");

        AnsiConsole.WriteLine("You can connect with this client using the following connection string:");
        AnsiConsole.MarkupLine(
            $"[bold]Endpoint={client.EndpointUrl};ClientId={result.Client.ClientId};ClientSecret={result.ClientSecret};[/]");
    }
}
